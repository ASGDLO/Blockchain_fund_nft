/// <reference types="@cloudflare/workers-types" />
/**
 * @typedef JwtAlgorithm
 * @type {'ES256'|'ES384'|'ES512'|'HS256'|'HS384'|'HS512'|'RS256'|'RS384'|'RS512'}
 */
export declare type JwtAlgorithm = 'ES256' | 'ES384' | 'ES512' | 'HS256' | 'HS384' | 'HS512' | 'RS256' | 'RS384' | 'RS512';
/**
 * @typedef JwtAlgorithms
 */
export interface JwtAlgorithms {
    [key: string]: SubtleCryptoImportKeyAlgorithm;
}
/**
 * @typedef JwtHeader
 * @prop {string} [typ] Type
 */
export interface JwtHeader {
    /**
     * Type (default: `"JWT"`)
     *
     * @default "JWT"
     */
    typ?: string;
    [key: string]: any;
}
/**
 * @typedef JwtPayload
 * @prop {string} [iss] Issuer
 * @prop {string} [sub] Subject
 * @prop {string} [aud] Audience
 * @prop {string} [exp] Expiration Time
 * @prop {string} [nbf] Not Before
 * @prop {string} [iat] Issued At
 * @prop {string} [jti] JWT ID
 */
export interface JwtPayload {
    /** Issuer */
    iss?: string;
    /** Subject */
    sub?: string;
    /** Audience */
    aud?: string;
    /** Expiration Time */
    exp?: number;
    /** Not Before */
    nbf?: number;
    /** Issued At */
    iat?: number;
    /** JWT ID */
    jti?: string;
    [key: string]: any;
}
/**
 * @typedef JwtOptions
 * @prop {JwtAlgorithm | string} algorithm
 */
export interface JwtOptions {
    algorithm?: JwtAlgorithm | string;
}
/**
 * @typedef JwtSignOptions
 * @extends JwtOptions
 * @prop {JwtHeader} [header]
 */
export interface JwtSignOptions extends JwtOptions {
    header?: JwtHeader;
}
/**
 * @typedef JwtVerifyOptions
 * @extends JwtOptions
 * @prop {boolean} [throwError=false] If `true` throw error if checks fail. (default: `false`)
 */
export interface JwtVerifyOptions extends JwtOptions {
    /**
     * If `true` throw error if checks fail. (default: `false`)
     *
     * @default false
    */
    throwError?: boolean;
}
/**
 * @typedef JwtData
 * @prop {JwtHeader} header
 * @prop {JwtPayload} payload
 */
export interface JwtData {
    header: JwtHeader;
    payload: JwtPayload;
}
/**
 * Signs a payload and returns the token
 *
 * @param {JwtPayload} payload The payload object. To use `nbf` (Not Before) and/or `exp` (Expiration Time) add `nbf` and/or `exp` to the payload.
 * @param {string} secret A string which is used to sign the payload.
 * @param {JwtSignOptions | JwtAlgorithm | string} [options={ algorithm: 'HS256', header: { typ: 'JWT' } }] The options object or the algorithm.
 * @throws {Error} If there's a validation issue.
 * @returns {Promise<string>} Returns token as a `string`.
 */
export declare function sign(payload: JwtPayload, secret: string, options?: JwtSignOptions | JwtAlgorithm): Promise<string>;
/**
 * Verifies the integrity of the token and returns a boolean value.
 *
 * @param {string} token The token string generated by `jwt.sign()`.
 * @param {string} secret The string which was used to sign the payload.
 * @param {JWTVerifyOptions | JWTAlgorithm} options The options object or the algorithm.
 * @throws {Error | string} Throws an error `string` if the token is invalid or an `Error-Object` if there's a validation issue.
 * @returns {Promise<boolean>} Returns `true` if signature, `nbf` (if set) and `exp` (if set) are valid, otherwise returns `false`.
 */
export declare function verify(token: string, secret: string, options?: JwtVerifyOptions | JwtAlgorithm): Promise<boolean>;
/**
 * Returns the payload **without** verifying the integrity of the token. Please use `jwt.verify()` first to keep your application secure!
 *
 * @param {string} token The token string generated by `jwt.sign()`.
 * @returns {JwtData} Returns an `object` containing `header` and `payload`.
 */
export declare function decode(token: string): JwtData;
declare const _default: {
    sign: typeof sign;
    verify: typeof verify;
    decode: typeof decode;
};
export default _default;
