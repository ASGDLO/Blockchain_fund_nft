"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var provider_1 = require("@ethereum-waffle/provider");
var __1 = require("..");
var chai_1 = require("chai");
var testing_1 = require("../testing");
var chainId_1 = require("../constants/chainId");
var ethereum_waffle_1 = require("ethereum-waffle");
var constants_1 = require("../constants");
var wait_for_expect_1 = __importDefault(require("wait-for-expect"));
describe('useCall', function () {
    var mockProvider = new provider_1.MockProvider();
    var secondMockProvider = new provider_1.MockProvider({ ganacheOptions: { _chainIdRpc: testing_1.SECOND_TEST_CHAIN_ID } });
    var deployer = mockProvider.getWallets()[0];
    var secondDeployer = secondMockProvider.getWallets()[0];
    var token;
    var secondToken;
    var chainId;
    var blockNumberContract;
    var secondBlockNumberContract;
    var revertContract;
    beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, mockProvider.getNetwork()];
                case 1:
                    chainId = (_a.sent()).chainId;
                    return [4 /*yield*/, (0, testing_1.deployMockToken)(deployer)];
                case 2:
                    token = _a.sent();
                    return [4 /*yield*/, (0, testing_1.deployMockToken)(secondDeployer, testing_1.SECOND_MOCK_TOKEN_INITIAL_BALANCE)];
                case 3:
                    secondToken = _a.sent();
                    return [4 /*yield*/, (0, ethereum_waffle_1.deployContract)(deployer, constants_1.BlockNumberContract)];
                case 4:
                    blockNumberContract = _a.sent();
                    return [4 /*yield*/, (0, ethereum_waffle_1.deployContract)(deployer, constants_1.BlockNumberContract)];
                case 5:
                    secondBlockNumberContract = _a.sent();
                    return [4 /*yield*/, (0, ethereum_waffle_1.deployContract)(deployer, constants_1.RevertContract)];
                case 6:
                    revertContract = _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    var _loop_1 = function (multicallVersion) {
        describe("Multicall v".concat(multicallVersion), function () {
            it('initial test balance to be correct', function () { return __awaiter(void 0, void 0, void 0, function () {
                var _a, result, waitForCurrent;
                var _b;
                var _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, (0, testing_1.renderWeb3Hook)(function () {
                                return (0, __1.useCall)({
                                    contract: token,
                                    method: 'balanceOf',
                                    args: [deployer.address]
                                });
                            }, {
                                readonlyMockProviders: (_b = {},
                                    _b[chainId] = mockProvider,
                                    _b),
                                multicallVersion: multicallVersion
                            })];
                        case 1:
                            _a = _d.sent(), result = _a.result, waitForCurrent = _a.waitForCurrent;
                            return [4 /*yield*/, waitForCurrent(function (val) { return val !== undefined; })];
                        case 2:
                            _d.sent();
                            (0, chai_1.expect)(result.error).to.be.undefined;
                            (0, chai_1.expect)((_c = result.current) === null || _c === void 0 ? void 0 : _c.value[0]).to.eq(testing_1.MOCK_TOKEN_INITIAL_BALANCE);
                            return [2 /*return*/];
                    }
                });
            }); });
            it('returns error on revert', function () { return __awaiter(void 0, void 0, void 0, function () {
                var _a, result, waitForCurrent;
                var _b;
                var _c, _d, _e;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0: return [4 /*yield*/, (0, testing_1.renderWeb3Hook)(function () {
                                return (0, __1.useCall)({
                                    contract: revertContract,
                                    method: 'doRevert',
                                    args: []
                                });
                            }, {
                                readonlyMockProviders: (_b = {},
                                    _b[chainId] = mockProvider,
                                    _b),
                                multicallVersion: multicallVersion
                            })];
                        case 1:
                            _a = _f.sent(), result = _a.result, waitForCurrent = _a.waitForCurrent;
                            return [4 /*yield*/, waitForCurrent(function (val) { return val !== undefined; })];
                        case 2:
                            _f.sent();
                            (0, chai_1.expect)((_c = result.current) === null || _c === void 0 ? void 0 : _c.value).to.be.undefined;
                            (0, chai_1.expect)(typeof ((_e = (_d = result.current) === null || _d === void 0 ? void 0 : _d.error) === null || _e === void 0 ? void 0 : _e.message)).to.eq('string');
                            return [2 /*return*/];
                    }
                });
            }); });
            it('multichain calls return correct initial balances', function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, testMultiChainUseCall(token, [deployer.address], chainId_1.ChainId.Localhost, testing_1.MOCK_TOKEN_INITIAL_BALANCE)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, testMultiChainUseCall(secondToken, [secondDeployer.address], testing_1.SECOND_TEST_CHAIN_ID, testing_1.SECOND_MOCK_TOKEN_INITIAL_BALANCE)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var testMultiChainUseCall = function (contract, args, chainId, endValue) { return __awaiter(void 0, void 0, void 0, function () {
                var _a, result, waitForCurrent;
                var _b;
                var _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, (0, testing_1.renderWeb3Hook)(function () {
                                return (0, __1.useCall)({
                                    contract: contract,
                                    method: 'balanceOf',
                                    args: args
                                }, { chainId: chainId });
                            }, {
                                readonlyMockProviders: (_b = {},
                                    _b[chainId_1.ChainId.Localhost] = mockProvider,
                                    _b[testing_1.SECOND_TEST_CHAIN_ID] = secondMockProvider,
                                    _b),
                                multicallVersion: multicallVersion
                            })];
                        case 1:
                            _a = _d.sent(), result = _a.result, waitForCurrent = _a.waitForCurrent;
                            return [4 /*yield*/, waitForCurrent(function (val) { return val !== undefined; })];
                        case 2:
                            _d.sent();
                            (0, chai_1.expect)(result.error).to.be.undefined;
                            (0, chai_1.expect)((_c = result.current) === null || _c === void 0 ? void 0 : _c.value[0]).to.eq(endValue);
                            return [2 /*return*/];
                    }
                });
            }); };
            it('Properly handles two calls', function () { return __awaiter(void 0, void 0, void 0, function () {
                var _a, result, waitForCurrent, mineBlock, blockNumber;
                var _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, (0, testing_1.renderWeb3Hook)(function () {
                                var balance = (0, __1.useCall)({
                                    contract: token,
                                    method: 'balanceOf',
                                    args: [deployer.address]
                                });
                                var block = (0, __1.useCall)({
                                    contract: blockNumberContract,
                                    method: 'getBlockNumber',
                                    args: []
                                });
                                return { balance: balance, block: block };
                            }, {
                                readonlyMockProviders: (_b = {},
                                    _b[chainId] = mockProvider,
                                    _b),
                                multicallVersion: multicallVersion
                            })];
                        case 1:
                            _a = _c.sent(), result = _a.result, waitForCurrent = _a.waitForCurrent, mineBlock = _a.mineBlock;
                            return [4 /*yield*/, mockProvider.getBlockNumber()];
                        case 2:
                            blockNumber = _c.sent();
                            return [4 /*yield*/, waitForCurrent(function (_a) {
                                    var balance = _a.balance, block = _a.block;
                                    return !!(balance && block);
                                })];
                        case 3:
                            _c.sent();
                            (0, chai_1.expect)(result.error).to.be.undefined;
                            (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'balance')).to.eq(testing_1.MOCK_TOKEN_INITIAL_BALANCE);
                            (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block')).to.eq(blockNumber);
                            return [4 /*yield*/, mineBlock()];
                        case 4:
                            _c.sent();
                            return [4 /*yield*/, (0, wait_for_expect_1["default"])(function () {
                                    (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'balance')).to.eq(testing_1.MOCK_TOKEN_INITIAL_BALANCE);
                                    (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block')).to.eq(blockNumber + 1);
                                })];
                        case 5:
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('Properly handles refresh per block', function () { return __awaiter(void 0, void 0, void 0, function () {
                var _a, result, waitForCurrent, mineBlock, blockNumber, i;
                var _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, (0, testing_1.renderWeb3Hook)(function () {
                                var block1 = (0, __1.useCall)({
                                    contract: blockNumberContract,
                                    method: 'getBlockNumber',
                                    args: []
                                });
                                var block2 = (0, __1.useCall)({
                                    // TODO: add similar test but with the same contract (blockNumberContract). It would currently fail
                                    contract: secondBlockNumberContract,
                                    method: 'getBlockNumber',
                                    args: []
                                }, {
                                    refresh: 2
                                });
                                return { block1: block1, block2: block2 };
                            }, {
                                readonlyMockProviders: (_b = {},
                                    _b[chainId] = mockProvider,
                                    _b),
                                multicallVersion: multicallVersion
                            })];
                        case 1:
                            _a = _c.sent(), result = _a.result, waitForCurrent = _a.waitForCurrent, mineBlock = _a.mineBlock;
                            return [4 /*yield*/, mockProvider.getBlockNumber()];
                        case 2:
                            blockNumber = _c.sent();
                            return [4 /*yield*/, waitForCurrent(function (_a) {
                                    var block1 = _a.block1, block2 = _a.block2;
                                    return !!(block1 && block2);
                                })];
                        case 3:
                            _c.sent();
                            (0, chai_1.expect)(result.error).to.be.undefined;
                            (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block1')).to.eq(blockNumber);
                            (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block2')).to.eq(blockNumber);
                            return [4 /*yield*/, mineBlock()];
                        case 4:
                            _c.sent();
                            return [4 /*yield*/, waitForCurrent(function (_a) {
                                    var block1 = _a.block1;
                                    return block1 !== undefined && block1.value[0].toNumber() === blockNumber + 1;
                                })];
                        case 5:
                            _c.sent();
                            (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block1')).to.eq(blockNumber + 1);
                            (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block2')).to.eq(blockNumber);
                            return [4 /*yield*/, mineBlock()];
                        case 6:
                            _c.sent();
                            return [4 /*yield*/, (0, wait_for_expect_1["default"])(function () {
                                    (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block1')).to.eq(blockNumber + 2);
                                    (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block2')).to.eq(blockNumber + 2);
                                })];
                        case 7:
                            _c.sent();
                            i = 0;
                            _c.label = 8;
                        case 8:
                            if (!(i < 3)) return [3 /*break*/, 11];
                            return [4 /*yield*/, mineBlock()];
                        case 9:
                            _c.sent();
                            _c.label = 10;
                        case 10:
                            i++;
                            return [3 /*break*/, 8];
                        case 11: return [4 /*yield*/, (0, wait_for_expect_1["default"])(function () {
                                (0, chai_1.expect)((0, testing_1.getResultPropery)(result, 'block1')).to.eq(blockNumber + 5);
                                var block2 = (0, testing_1.getResultPropery)(result, 'block2').toNumber();
                                // we don't actually know when the update is gonna happen - both possibilities are possible
                                (0, chai_1.expect)(block2 === blockNumber + 4 || block2 === blockNumber + 5).to.be["true"];
                            })];
                        case 12:
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('Refreshes static call on parameter change', function () { return __awaiter(void 0, void 0, void 0, function () {
                var _a, config, network1, deployer, doublerContract, _b, waitForCurrent, rerender;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, (0, testing_1.setupTestingConfig)()];
                        case 1:
                            _a = _c.sent(), config = _a.config, network1 = _a.network1;
                            deployer = network1.provider.getWallets()[0];
                            return [4 /*yield*/, (0, ethereum_waffle_1.deployContract)(deployer, constants_1.doublerContractABI)];
                        case 2:
                            doublerContract = _c.sent();
                            return [4 /*yield*/, (0, testing_1.renderDAppHook)(function (_a) {
                                    var num = _a.num;
                                    return (0, __1.useCall)({
                                        contract: doublerContract,
                                        method: 'double',
                                        args: [num]
                                    });
                                }, {
                                    config: __assign(__assign({}, config), { refresh: 'never' }),
                                    renderHook: {
                                        initialProps: {
                                            num: 1
                                        }
                                    }
                                })];
                        case 3:
                            _b = _c.sent(), waitForCurrent = _b.waitForCurrent, rerender = _b.rerender;
                            return [4 /*yield*/, waitForCurrent(function (val) { var _a, _b; return (_b = (_a = val === null || val === void 0 ? void 0 : val.value) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.eq(2); })];
                        case 4:
                            _c.sent();
                            rerender({ num: 2 });
                            return [4 /*yield*/, waitForCurrent(function (val) { var _a, _b; return (_b = (_a = val === null || val === void 0 ? void 0 : val.value) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.eq(4); })];
                        case 5:
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('Refreshes only static calls with changed parameter', function () { return __awaiter(void 0, void 0, void 0, function () {
                var _a, config, network1, deployer, doublerContract, blockNumberContract, _b, waitForCurrent, rerender, result, blockNumberBefore;
                var _c, _d, _e, _f;
                return __generator(this, function (_g) {
                    switch (_g.label) {
                        case 0: return [4 /*yield*/, (0, testing_1.setupTestingConfig)()];
                        case 1:
                            _a = _g.sent(), config = _a.config, network1 = _a.network1;
                            deployer = network1.provider.getWallets()[0];
                            return [4 /*yield*/, (0, ethereum_waffle_1.deployContract)(deployer, constants_1.doublerContractABI)];
                        case 2:
                            doublerContract = _g.sent();
                            return [4 /*yield*/, (0, ethereum_waffle_1.deployContract)(deployer, constants_1.BlockNumberContract)];
                        case 3:
                            blockNumberContract = _g.sent();
                            return [4 /*yield*/, (0, testing_1.renderDAppHook)(function (_a) {
                                    var num = _a.num;
                                    var doubled = (0, __1.useCall)({
                                        contract: doublerContract,
                                        method: 'double',
                                        args: [num]
                                    });
                                    var blockNumber = (0, __1.useCall)({
                                        contract: blockNumberContract,
                                        method: 'getBlockNumber',
                                        args: []
                                    });
                                    return { doubled: doubled, blockNumber: blockNumber };
                                }, {
                                    config: __assign(__assign({}, config), { refresh: 'never' }),
                                    renderHook: {
                                        initialProps: {
                                            num: 1
                                        }
                                    }
                                })];
                        case 4:
                            _b = _g.sent(), waitForCurrent = _b.waitForCurrent, rerender = _b.rerender, result = _b.result;
                            return [4 /*yield*/, waitForCurrent(function (val) { var _a, _b, _c; return (_c = (_b = (_a = val === null || val === void 0 ? void 0 : val.doubled) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.eq(2); })];
                        case 5:
                            _g.sent();
                            blockNumberBefore = (_c = result.current.blockNumber) === null || _c === void 0 ? void 0 : _c.value[0];
                            return [4 /*yield*/, (0, testing_1.mineBlock)(network1.provider)];
                        case 6:
                            _g.sent();
                            (0, chai_1.expect)((_d = result.current.doubled) === null || _d === void 0 ? void 0 : _d.value[0]).to.eq(2);
                            (0, chai_1.expect)((_e = result.current.blockNumber) === null || _e === void 0 ? void 0 : _e.value[0]).to.eq(blockNumberBefore);
                            rerender({ num: 2 });
                            return [4 /*yield*/, waitForCurrent(function (val) { var _a, _b, _c; return (_c = (_b = (_a = val === null || val === void 0 ? void 0 : val.doubled) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.eq(4); })];
                        case 7:
                            _g.sent();
                            (0, chai_1.expect)((_f = result.current.blockNumber) === null || _f === void 0 ? void 0 : _f.value[0]).to.eq(blockNumberBefore);
                            return [2 /*return*/];
                    }
                });
            }); });
        });
    };
    for (var _i = 0, _a = [1]; _i < _a.length; _i++) {
        var multicallVersion = _a[_i];
        _loop_1(multicallVersion);
    }
});
//# sourceMappingURL=useCall.test.js.map