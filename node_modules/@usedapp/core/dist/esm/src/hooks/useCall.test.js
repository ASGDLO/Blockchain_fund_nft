import { MockProvider } from '@ethereum-waffle/provider';
import { useCall } from '..';
import { expect } from 'chai';
import { renderWeb3Hook, deployMockToken, MOCK_TOKEN_INITIAL_BALANCE, SECOND_TEST_CHAIN_ID, SECOND_MOCK_TOKEN_INITIAL_BALANCE, getResultPropery, renderDAppHook, setupTestingConfig, mineBlock, } from '../testing';
import { ChainId } from '../constants/chainId';
import { deployContract } from 'ethereum-waffle';
import { BlockNumberContract, RevertContract, doublerContractABI } from '../constants';
import waitForExpect from 'wait-for-expect';
describe('useCall', () => {
    const mockProvider = new MockProvider();
    const secondMockProvider = new MockProvider({ ganacheOptions: { _chainIdRpc: SECOND_TEST_CHAIN_ID } });
    const [deployer] = mockProvider.getWallets();
    const [secondDeployer] = secondMockProvider.getWallets();
    let token;
    let secondToken;
    let chainId;
    let blockNumberContract;
    let secondBlockNumberContract;
    let revertContract;
    beforeEach(async () => {
        chainId = (await mockProvider.getNetwork()).chainId;
        token = await deployMockToken(deployer);
        secondToken = await deployMockToken(secondDeployer, SECOND_MOCK_TOKEN_INITIAL_BALANCE);
        blockNumberContract = await deployContract(deployer, BlockNumberContract);
        secondBlockNumberContract = await deployContract(deployer, BlockNumberContract);
        revertContract = await deployContract(deployer, RevertContract);
    });
    for (const multicallVersion of [1]) {
        describe(`Multicall v${multicallVersion}`, () => {
            it('initial test balance to be correct', async () => {
                var _a;
                const { result, waitForCurrent } = await renderWeb3Hook(() => useCall({
                    contract: token,
                    method: 'balanceOf',
                    args: [deployer.address],
                }), {
                    readonlyMockProviders: {
                        [chainId]: mockProvider,
                    },
                    multicallVersion,
                });
                await waitForCurrent((val) => val !== undefined);
                expect(result.error).to.be.undefined;
                expect((_a = result.current) === null || _a === void 0 ? void 0 : _a.value[0]).to.eq(MOCK_TOKEN_INITIAL_BALANCE);
            });
            it('returns error on revert', async () => {
                var _a, _b, _c;
                const { result, waitForCurrent } = await renderWeb3Hook(() => useCall({
                    contract: revertContract,
                    method: 'doRevert',
                    args: [],
                }), {
                    readonlyMockProviders: {
                        [chainId]: mockProvider,
                    },
                    multicallVersion,
                });
                await waitForCurrent((val) => val !== undefined);
                expect((_a = result.current) === null || _a === void 0 ? void 0 : _a.value).to.be.undefined;
                expect(typeof ((_c = (_b = result.current) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.message)).to.eq('string');
            });
            it('multichain calls return correct initial balances', async () => {
                await testMultiChainUseCall(token, [deployer.address], ChainId.Localhost, MOCK_TOKEN_INITIAL_BALANCE);
                await testMultiChainUseCall(secondToken, [secondDeployer.address], SECOND_TEST_CHAIN_ID, SECOND_MOCK_TOKEN_INITIAL_BALANCE);
            });
            const testMultiChainUseCall = async (contract, args, chainId, endValue) => {
                var _a;
                const { result, waitForCurrent } = await renderWeb3Hook(() => useCall({
                    contract,
                    method: 'balanceOf',
                    args,
                }, { chainId }), {
                    readonlyMockProviders: {
                        [ChainId.Localhost]: mockProvider,
                        [SECOND_TEST_CHAIN_ID]: secondMockProvider,
                    },
                    multicallVersion,
                });
                await waitForCurrent((val) => val !== undefined);
                expect(result.error).to.be.undefined;
                expect((_a = result.current) === null || _a === void 0 ? void 0 : _a.value[0]).to.eq(endValue);
            };
            it('Properly handles two calls', async () => {
                const { result, waitForCurrent, mineBlock } = await renderWeb3Hook(() => {
                    const balance = useCall({
                        contract: token,
                        method: 'balanceOf',
                        args: [deployer.address],
                    });
                    const block = useCall({
                        contract: blockNumberContract,
                        method: 'getBlockNumber',
                        args: [],
                    });
                    return { balance, block };
                }, {
                    readonlyMockProviders: {
                        [chainId]: mockProvider,
                    },
                    multicallVersion,
                });
                const blockNumber = await mockProvider.getBlockNumber();
                await waitForCurrent(({ balance, block }) => !!(balance && block));
                expect(result.error).to.be.undefined;
                expect(getResultPropery(result, 'balance')).to.eq(MOCK_TOKEN_INITIAL_BALANCE);
                expect(getResultPropery(result, 'block')).to.eq(blockNumber);
                await mineBlock();
                await waitForExpect(() => {
                    expect(getResultPropery(result, 'balance')).to.eq(MOCK_TOKEN_INITIAL_BALANCE);
                    expect(getResultPropery(result, 'block')).to.eq(blockNumber + 1);
                });
            });
            it('Properly handles refresh per block', async () => {
                const { result, waitForCurrent, mineBlock } = await renderWeb3Hook(() => {
                    const block1 = useCall({
                        contract: blockNumberContract,
                        method: 'getBlockNumber',
                        args: [],
                    });
                    const block2 = useCall({
                        // TODO: add similar test but with the same contract (blockNumberContract). It would currently fail
                        contract: secondBlockNumberContract,
                        method: 'getBlockNumber',
                        args: [],
                    }, {
                        refresh: 2,
                    });
                    return { block1, block2 };
                }, {
                    readonlyMockProviders: {
                        [chainId]: mockProvider,
                    },
                    multicallVersion,
                });
                const blockNumber = await mockProvider.getBlockNumber();
                await waitForCurrent(({ block1, block2 }) => !!(block1 && block2));
                expect(result.error).to.be.undefined;
                expect(getResultPropery(result, 'block1')).to.eq(blockNumber);
                expect(getResultPropery(result, 'block2')).to.eq(blockNumber);
                await mineBlock();
                await waitForCurrent(({ block1 }) => block1 !== undefined && block1.value[0].toNumber() === blockNumber + 1);
                expect(getResultPropery(result, 'block1')).to.eq(blockNumber + 1);
                expect(getResultPropery(result, 'block2')).to.eq(blockNumber);
                await mineBlock();
                await waitForExpect(() => {
                    expect(getResultPropery(result, 'block1')).to.eq(blockNumber + 2);
                    expect(getResultPropery(result, 'block2')).to.eq(blockNumber + 2);
                });
                for (let i = 0; i < 3; i++) {
                    await mineBlock();
                }
                await waitForExpect(() => {
                    expect(getResultPropery(result, 'block1')).to.eq(blockNumber + 5);
                    const block2 = getResultPropery(result, 'block2').toNumber();
                    // we don't actually know when the update is gonna happen - both possibilities are possible
                    expect(block2 === blockNumber + 4 || block2 === blockNumber + 5).to.be.true;
                });
            });
            it('Refreshes static call on parameter change', async () => {
                const { config, network1 } = await setupTestingConfig();
                const [deployer] = network1.provider.getWallets();
                const doublerContract = await deployContract(deployer, doublerContractABI);
                const { waitForCurrent, rerender } = await renderDAppHook(({ num }) => useCall({
                    contract: doublerContract,
                    method: 'double',
                    args: [num],
                }), {
                    config: Object.assign(Object.assign({}, config), { refresh: 'never' }),
                    renderHook: {
                        initialProps: {
                            num: 1,
                        },
                    },
                });
                await waitForCurrent((val) => { var _a, _b; return (_b = (_a = val === null || val === void 0 ? void 0 : val.value) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.eq(2); });
                rerender({ num: 2 });
                await waitForCurrent((val) => { var _a, _b; return (_b = (_a = val === null || val === void 0 ? void 0 : val.value) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.eq(4); });
            });
            it('Refreshes only static calls with changed parameter', async () => {
                var _a, _b, _c, _d;
                const { config, network1 } = await setupTestingConfig();
                const [deployer] = network1.provider.getWallets();
                const doublerContract = await deployContract(deployer, doublerContractABI);
                const blockNumberContract = await deployContract(deployer, BlockNumberContract);
                const { waitForCurrent, rerender, result } = await renderDAppHook(({ num }) => {
                    const doubled = useCall({
                        contract: doublerContract,
                        method: 'double',
                        args: [num],
                    });
                    const blockNumber = useCall({
                        contract: blockNumberContract,
                        method: 'getBlockNumber',
                        args: [],
                    });
                    return { doubled, blockNumber };
                }, {
                    config: Object.assign(Object.assign({}, config), { refresh: 'never' }),
                    renderHook: {
                        initialProps: {
                            num: 1,
                        },
                    },
                });
                await waitForCurrent((val) => { var _a, _b, _c; return (_c = (_b = (_a = val === null || val === void 0 ? void 0 : val.doubled) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.eq(2); });
                const blockNumberBefore = (_a = result.current.blockNumber) === null || _a === void 0 ? void 0 : _a.value[0];
                await mineBlock(network1.provider);
                expect((_b = result.current.doubled) === null || _b === void 0 ? void 0 : _b.value[0]).to.eq(2);
                expect((_c = result.current.blockNumber) === null || _c === void 0 ? void 0 : _c.value[0]).to.eq(blockNumberBefore);
                rerender({ num: 2 });
                await waitForCurrent((val) => { var _a, _b, _c; return (_c = (_b = (_a = val === null || val === void 0 ? void 0 : val.doubled) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.eq(4); });
                expect((_d = result.current.blockNumber) === null || _d === void 0 ? void 0 : _d.value[0]).to.eq(blockNumberBefore);
            });
        });
    }
});
//# sourceMappingURL=useCall.test.js.map